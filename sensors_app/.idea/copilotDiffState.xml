<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/io/sensor_prod/sensor/ui/pages/home/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/io/sensor_prod/sensor/ui/pages/home/HomeViewModel.kt" />
              <option name="originalContent" value="package io.sensor_prod.sensor.ui.pages.home&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.Build&#10;import android.os.Environment&#10;import android.util.Log&#10;import androidx.annotation.RequiresApi&#10;import androidx.annotation.RequiresPermission&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.snapshots.SnapshotStateList&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import io.sensor_prod.sensor.domains.chart.mpchart.MpChartDataManager&#10;import io.sensor_prod.sensor.domains.sensors.SensorsConstants&#10;import io.sensor_prod.sensor.domains.sensors.packets.SensorPacketConfig&#10;import io.sensor_prod.sensor.domains.sensors.packets.SensorPacketsProvider&#10;import io.sensor_prod.sensor.domains.sensors.provider.SensorsProvider&#10;import io.sensor_prod.sensor.ui.pages.home.model.ModelHomeSensor&#10;import io.sensor_prod.sensor.ui.pages.home.state.HomeUiState&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.io.BufferedWriter&#10;import java.io.File&#10;import java.io.FileWriter&#10;import kotlin.math.sqrt&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;import java.util.TimeZone&#10;// BLE&#10;import android.bluetooth.BluetoothAdapter&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothSocket&#10;import java.io.InputStream&#10;import java.io.IOException&#10;import java.util.UUID&#10;&#10;&#10;class HomeViewModel : ViewModel() {&#10;&#10;    private var mSensors: MutableList&lt;ModelHomeSensor&gt; = mutableListOf()&#10;    private var lastDetectionTime = 0L&#10;    private val cooldownMillis = 5000L // 5 seconds&#10;&#10;    // Adjustable RMS threshold&#10;    private val WINDOW_SIZE = 10&#10;    val thresholdFlow = MutableStateFlow(4f)&#10;    fun setThreshold(value: Float) { thresholdFlow.value = value }&#10;&#10;    private val gyroscopeValues = mutableListOf&lt;Float&gt;()&#10;&#10;    private val sensorEventListener = object : SensorEventListener {&#10;        @RequiresApi(Build.VERSION_CODES.VANILLA_ICE_CREAM)&#10;        override fun onSensorChanged(event: SensorEvent?) {&#10;            event?.let {&#10;                if (event.sensor.type == Sensor.TYPE_GYROSCOPE) {&#10;                    val x = event.values[0]&#10;                    val y = event.values[1]&#10;                    val z = event.values[2]&#10;                    val magnitude = sqrt(x * x + y * y + z * z)&#10;                    if (gyroscopeValues.size &gt;= WINDOW_SIZE) gyroscopeValues.removeFirst()&#10;                    gyroscopeValues.add(magnitude)&#10;                    checkPotholeFromSensors()&#10;                }&#10;            }&#10;        }&#10;        override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}&#10;    }&#10;&#10;    private val _potholeDetected = MutableStateFlow(false)&#10;    val potholeDetected: StateFlow&lt;Boolean&gt; = _potholeDetected.asStateFlow()&#10;&#10;    fun startGyroListening(context: Context) {&#10;        val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager&#10;        val gyroscope = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE)&#10;        sensorManager.registerListener(sensorEventListener, gyroscope, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    private fun checkPotholeFromSensors() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastDetectionTime &lt; cooldownMillis) return&#10;        if (gyroscopeValues.size &lt; WINDOW_SIZE) return&#10;        val rms = sqrt(gyroscopeValues.map { it * it }.average().toFloat())&#10;        val pothole = rms &gt; thresholdFlow.value&#10;        if (pothole) {&#10;            lastDetectionTime = now&#10;            _potholeDetected.value = true&#10;            Log.d(&quot;POTHOLE&quot;, &quot;RMS threshold exceeded. RMS=$rms, threshold=${thresholdFlow.value}&quot;)&#10;        } else {&#10;            _potholeDetected.value = false&#10;        }&#10;    }&#10;&#10;    // Game UI state&#10;    private val _uiState = MutableStateFlow(HomeUiState())&#10;    val mUiState: StateFlow&lt;HomeUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _mSensorsList = mutableStateListOf&lt;ModelHomeSensor&gt;()&#10;    val mSensorsList: SnapshotStateList&lt;ModelHomeSensor&gt; = _mSensorsList&#10;&#10;    private val _mActiveSensorListFlow = MutableStateFlow&lt;MutableList&lt;ModelHomeSensor&gt;&gt;(mutableListOf())&#10;    val mActiveSensorListFlow: StateFlow&lt;MutableList&lt;ModelHomeSensor&gt;&gt; = _mActiveSensorListFlow&#10;    private val _mActiveSensorList = mutableListOf&lt;ModelHomeSensor&gt;()&#10;&#10;    private val mIsActiveMap = mutableMapOf&lt;Int, Boolean&gt;(Pair(Sensor.TYPE_GYROSCOPE, true))&#10;    private val mChartDataManagerMap = mutableMapOf&lt;Int, MpChartDataManager&gt;()&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            SensorsProvider.getInstance().mSensorsFlow.map { value -&gt;&#10;                value.map {&#10;                    ModelHomeSensor(&#10;                        it.type,&#10;                        it.sensor,&#10;                        it.info,&#10;                        0f,&#10;                        mIsActiveMap.getOrDefault(it.type, false)&#10;                    )&#10;                }.toMutableList()&#10;            }.collectLatest {&#10;                mSensors = it&#10;                if (_mSensorsList.size == 0) {&#10;                    _mSensorsList.addAll(mSensors)&#10;                    val activeSensors = it.filter { modelHomeSensor -&gt; modelHomeSensor.isActive }&#10;                    _mActiveSensorList.addAll(activeSensors)&#10;                    _mActiveSensorListFlow.emit(_mActiveSensorList)&#10;                    getInitialChartData()&#10;                    initializeFlow()&#10;                }&#10;            }&#10;        }&#10;        SensorsProvider.getInstance().listenSensors()&#10;    }&#10;&#10;    private fun getInitialChartData() { for (sensor in _mActiveSensorList) { getChartDataManager(sensor.type) } }&#10;&#10;    // Logging to CSV (sensors)&#10;    private var csvFile: File? = null&#10;    private var writer: BufferedWriter? = null&#10;    private var isLogging = MutableStateFlow(false)&#10;    private var currentDateString: String? = null&#10;    private val tzIST: TimeZone = TimeZone.getTimeZone(&quot;Asia/Kolkata&quot;)&#10;    private val dateFormatterIST = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.US).apply { timeZone = tzIST }&#10;    private val timeFormatterIST = SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;, Locale.US).apply { timeZone = tzIST }&#10;&#10;    private fun baseCsvDir(): File {&#10;        val docs = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS)&#10;        val folder = File(docs, &quot;SensifyCSV&quot;)&#10;        if (!folder.exists()) folder.mkdirs()&#10;        return folder&#10;    }&#10;    private fun fileForDate(dateStr: String): File = File(baseCsvDir(), &quot;sensor_data_${dateStr}.csv&quot;)&#10;&#10;    private fun openWriterForDate(dateStr: String) {&#10;        val file = fileForDate(dateStr)&#10;        val isNew = !file.exists()&#10;        writer = BufferedWriter(FileWriter(file, true))&#10;        csvFile = file&#10;        if (isNew) {&#10;            val header = StringBuilder(&quot;Time,SensorType&quot;)&#10;            var maxAxisCount = 3&#10;            for (i in 0 until SensorsConstants.MAP_TYPE_TO_AXIS_COUNT.size()) {&#10;                val axisCount = SensorsConstants.MAP_TYPE_TO_AXIS_COUNT.valueAt(i)&#10;                if (axisCount &gt; maxAxisCount) maxAxisCount = axisCount&#10;            }&#10;            for (i in 0 until maxAxisCount) header.append(&quot;,Value${i + 1}&quot;)&#10;            header.append(&quot;\n&quot;)&#10;            writer?.write(header.toString())&#10;        }&#10;        Log.d(&quot;CSV&quot;, &quot;Logging to: ${file.absolutePath}&quot;)&#10;    }&#10;&#10;    private fun rotateIfNeeded(nowMs: Long) {&#10;        val today = dateFormatterIST.format(Date(nowMs))&#10;        if (currentDateString == null || currentDateString != today || writer == null) {&#10;            try { writer?.flush(); writer?.close() } catch (_: Exception) {}&#10;            currentDateString = today&#10;            openWriterForDate(today)&#10;        }&#10;    }&#10;&#10;    private fun startCsvLogging() { val now = System.currentTimeMillis(); rotateIfNeeded(now); isLogging.value = true }&#10;    private fun stopCsvLogging() { isLogging.value = false; try { writer?.flush(); writer?.close() } catch (_: Exception) {}; writer = null; csvFile = null; Log.d(&quot;CSV&quot;, &quot;Logging Stopped&quot;) }&#10;    fun toggleCsvLogging() { if (isLogging.value) stopCsvLogging() else startCsvLogging() }&#10;&#10;    private fun logSensorData(sensorType: Int, values: FloatArray?) {&#10;        if (isLogging.value &amp;&amp; values != null) {&#10;            val now = System.currentTimeMillis()&#10;            rotateIfNeeded(now)&#10;            val timeStr = timeFormatterIST.format(Date(now))&#10;            val sensorName = SensorsConstants.MAP_TYPE_TO_NAME[sensorType] ?: &quot;Unknown&quot;&#10;            val axisCount = SensorsConstants.MAP_TYPE_TO_AXIS_COUNT[sensorType]&#10;            val csvLine = StringBuilder()&#10;            csvLine.append(&quot;$timeStr,$sensorName&quot;)&#10;            for (i in 0 until axisCount) {&#10;                val v = if (i &lt; values.size) String.format(Locale.US, &quot;%.6f&quot;, values[i]) else &quot;&quot;&#10;                csvLine.append(&quot;,&quot;).append(v)&#10;            }&#10;            csvLine.append(&quot;\n&quot;)&#10;            writer?.write(csvLine.toString())&#10;        }&#10;    }&#10;&#10;    private fun initializeFlow() {&#10;        val sensorPacketFlow = SensorPacketsProvider.getInstance().mSensorPacketFlow&#10;        for (sensor in _mActiveSensorList) { attachPacketListener(sensor) }&#10;        viewModelScope.launch { sensorPacketFlow.collect { logSensorData(it.type, it.values); mChartDataManagerMap[it.type]?.addEntry(it) } }&#10;        mChartDataManagerMap.forEach { (_, mpChartDataManager) -&gt; viewModelScope.launch { mpChartDataManager.runPeriodically() } }&#10;    }&#10;&#10;    private fun attachPacketListener(sensor: ModelHomeSensor) { SensorPacketsProvider.getInstance().attachSensor(SensorPacketConfig(sensor.type, SensorManager.SENSOR_DELAY_NORMAL)) }&#10;    private fun detachPacketListener(sensor: ModelHomeSensor) { SensorPacketsProvider.getInstance().detachSensor(sensor.type) }&#10;&#10;    fun onSensorChecked(type: Int, isChecked: Boolean) {&#10;        val isCheckedPrev = mIsActiveMap.getOrDefault(type, false)&#10;        if (isCheckedPrev != isChecked) mIsActiveMap[type] = isChecked&#10;        val index = mSensors.indexOfFirst { it.type == type }&#10;        if (index &gt;= 0) {&#10;            val sensor = mSensors[index]&#10;            val updatedSensor = ModelHomeSensor(sensor.type, sensor.sensor, sensor.info, sensor.valueRms, isChecked)&#10;            mSensors[index] = updatedSensor&#10;            mSensorsList[index] = updatedSensor&#10;            updateActiveSensor(updatedSensor, isChecked)&#10;        }&#10;    }&#10;&#10;    private fun updateActiveSensor(sensor: ModelHomeSensor, isChecked: Boolean = false) {&#10;        val index = _mActiveSensorList.indexOfFirst { it.type == sensor.type }&#10;        if (!isChecked &amp;&amp; index &gt;= 0) {&#10;            val manager = mChartDataManagerMap.remove(sensor.type)&#10;            manager?.destroy()&#10;            detachPacketListener(sensor)&#10;            _mActiveSensorList.removeAt(index)&#10;            viewModelScope.launch { _mActiveSensorListFlow.emit(_mActiveSensorList) }&#10;        } else if (isChecked &amp;&amp; index &lt; 0) {&#10;            _mActiveSensorList.add(sensor)&#10;            attachPacketListener(sensor)&#10;            viewModelScope.launch { _mActiveSensorListFlow.emit(_mActiveSensorList) }&#10;            getChartDataManager(type = sensor.type).runPeriodically()&#10;        }&#10;    }&#10;&#10;    fun getChartDataManager(type: Int): MpChartDataManager {&#10;        val chartDataManager = mChartDataManagerMap.getOrPut(type, defaultValue = { MpChartDataManager(type, onDestroy = { }) })&#10;        Log.d(&quot;HomeViewModel&quot;, &quot;getChartDataManager: $type&quot;)&#10;        return chartDataManager&#10;    }&#10;&#10;    fun setActivePage(page: Int?) {&#10;        viewModelScope.launch {&#10;            if (page != null &amp;&amp; _mActiveSensorList.size &gt; 0) {&#10;                if(_mActiveSensorList.size &gt; page){&#10;                    val sensor = _mActiveSensorList[page]&#10;                    _uiState.emit(_uiState.value.copy(currentSensor = sensor, activeSensorCounts = _mActiveSensorList.size))&#10;                }else{&#10;                    val sensor = _mActiveSensorList[_mActiveSensorList.size-1]&#10;                    _uiState.emit(_uiState.value.copy(currentSensor = sensor, activeSensorCounts = _mActiveSensorList.size))&#10;                }&#10;            } else {&#10;                _uiState.emit(_uiState.value.copy(currentSensor = null, activeSensorCounts = _mActiveSensorList.size))&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        // Close BLE on clear&#10;        disconnectBle()&#10;        mChartDataManagerMap.forEach { (_, mpChartDataManager) -&gt; mpChartDataManager.destroy() }&#10;    }&#10;&#10;    // ===== BLE integration (migrated) =====&#10;    val bleConnectedDevice = MutableStateFlow&lt;BluetoothDevice?&gt;(null)&#10;    private var bleSocket: BluetoothSocket? = null&#10;    private var bleReceiverJob: Job? = null&#10;    val bleLogging = MutableStateFlow(false)&#10;&#10;    private var bleWriter: BufferedWriter? = null&#10;    private var bleCurrentDateString: String? = null&#10;    private fun bleFileForDate(dateStr: String): File = File(baseCsvDir(), &quot;bluetooth_data_${dateStr}.csv&quot;)&#10;    private fun bleOpenWriterForDate(dateStr: String) {&#10;        val file = bleFileForDate(dateStr)&#10;        val isNew = !file.exists()&#10;        bleWriter = BufferedWriter(FileWriter(file, true))&#10;        if (isNew) { bleWriter?.write(&quot;Time,Data\n&quot;) }&#10;    }&#10;    private fun bleRotateIfNeeded(nowMs: Long) {&#10;        val today = dateFormatterIST.format(Date(nowMs))&#10;        if (bleCurrentDateString == null || bleCurrentDateString != today || bleWriter == null) {&#10;            try { bleWriter?.flush(); bleWriter?.close() } catch (_: Exception) {}&#10;            bleCurrentDateString = today&#10;            bleOpenWriterForDate(today)&#10;        }&#10;    }&#10;&#10;    fun toggleBleLogging() { bleLogging.value = !bleLogging.value }&#10;&#10;    @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)&#10;    fun connectBle(device: BluetoothDevice, onError: ((Exception) -&gt; Unit)? = null) {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                // Close any previous&#10;                disconnectBle()&#10;                val socket = device.createRfcommSocketToServiceRecord(UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;))&#10;                socket.connect()&#10;                bleSocket = socket&#10;                bleConnectedDevice.emit(device)&#10;                bleReceiverJob = launch(Dispatchers.IO) { receiveBleData(socket) }&#10;            } catch (e: Exception) {&#10;                onError?.invoke(e as? Exception ?: RuntimeException(&quot;BLE error&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnectBle() {&#10;        try { bleReceiverJob?.cancel() } catch (_: Exception) {}&#10;        bleReceiverJob = null&#10;        try { bleSocket?.close() } catch (_: Exception) {}&#10;        bleSocket = null&#10;        viewModelScope.launch { bleConnectedDevice.emit(null) }&#10;        try { bleWriter?.flush(); bleWriter?.close() } catch (_: Exception) {}&#10;        bleWriter = null&#10;        bleCurrentDateString = null&#10;    }&#10;&#10;    private suspend fun receiveBleData(socket: BluetoothSocket) {&#10;        try {&#10;            val input: InputStream = socket.inputStream&#10;            val buffer = ByteArray(1024)&#10;            var carry = &quot;&quot;&#10;            while (true) {&#10;                val bytesRead = input.read(buffer)&#10;                if (bytesRead &lt;= 0) continue&#10;                val chunk = String(buffer, 0, bytesRead)&#10;                val combined = carry + chunk&#10;                val lines = combined.split('\n')&#10;                for (i in 0 until lines.size - 1) { handleBleLine(lines[i].trim()) }&#10;                carry = lines.last()&#10;            }&#10;        } catch (e: IOException) {&#10;            Log.e(&quot;BLE&quot;, &quot;receive error: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleBleLine(line: String) {&#10;        if (line.isEmpty()) return&#10;        if (bleLogging.value) {&#10;            val now = System.currentTimeMillis()&#10;            bleRotateIfNeeded(now)&#10;            val timeStr = timeFormatterIST.format(Date(now))&#10;            try { bleWriter?.write(&quot;$timeStr,$line\n&quot;) } catch (e: Exception) { Log.e(&quot;BLE&quot;, &quot;write fail: ${e.message}&quot;) }&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        // Simple factory so callers can use: viewModel(factory = HomeViewModel.Factory)&#10;        val Factory: ViewModelProvider.Factory = object : ViewModelProvider.Factory {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;                return HomeViewModel() as T&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package io.sensor_prod.sensor.ui.pages.home&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.Build&#10;import android.os.Environment&#10;import android.util.Log&#10;import androidx.annotation.RequiresApi&#10;import androidx.annotation.RequiresPermission&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.snapshots.SnapshotStateList&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import io.sensor_prod.sensor.domains.chart.mpchart.MpChartDataManager&#10;import io.sensor_prod.sensor.domains.sensors.SensorsConstants&#10;import io.sensor_prod.sensor.domains.sensors.packets.SensorPacketConfig&#10;import io.sensor_prod.sensor.domains.sensors.packets.SensorPacketsProvider&#10;import io.sensor_prod.sensor.domains.sensors.provider.SensorsProvider&#10;import io.sensor_prod.sensor.ui.pages.home.model.ModelHomeSensor&#10;import io.sensor_prod.sensor.ui.pages.home.state.HomeUiState&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.io.BufferedWriter&#10;import java.io.File&#10;import java.io.FileWriter&#10;import kotlin.math.sqrt&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;import java.util.TimeZone&#10;// BLE&#10;import android.bluetooth.BluetoothAdapter&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothSocket&#10;import java.io.InputStream&#10;import java.io.IOException&#10;import java.util.UUID&#10;// Location&#10;import android.location.Location&#10;import android.location.LocationListener&#10;import android.location.LocationManager&#10;import android.os.Looper&#10;import androidx.core.content.ContextCompat&#10;import android.content.pm.PackageManager&#10;&#10;&#10;class HomeViewModel : ViewModel() {&#10;&#10;    private var mSensors: MutableList&lt;ModelHomeSensor&gt; = mutableListOf()&#10;    private var lastDetectionTime = 0L&#10;    private val cooldownMillis = 5000L // 5 seconds&#10;&#10;    // Adjustable RMS threshold&#10;    private val WINDOW_SIZE = 10&#10;    val thresholdFlow = MutableStateFlow(4f)&#10;    fun setThreshold(value: Float) { thresholdFlow.value = value }&#10;&#10;    private val gyroscopeValues = mutableListOf&lt;Float&gt;()&#10;&#10;    private val sensorEventListener = object : SensorEventListener {&#10;        @RequiresApi(Build.VERSION_CODES.VANILLA_ICE_CREAM)&#10;        override fun onSensorChanged(event: SensorEvent?) {&#10;            event?.let {&#10;                if (event.sensor.type == Sensor.TYPE_GYROSCOPE) {&#10;                    val x = event.values[0]&#10;                    val y = event.values[1]&#10;                    val z = event.values[2]&#10;                    val magnitude = sqrt(x * x + y * y + z * z)&#10;                    if (gyroscopeValues.size &gt;= WINDOW_SIZE) gyroscopeValues.removeFirst()&#10;                    gyroscopeValues.add(magnitude)&#10;                    checkPotholeFromSensors()&#10;                }&#10;            }&#10;        }&#10;        override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}&#10;    }&#10;&#10;    private val _potholeDetected = MutableStateFlow(false)&#10;    val potholeDetected: StateFlow&lt;Boolean&gt; = _potholeDetected.asStateFlow()&#10;&#10;    fun startGyroListening(context: Context) {&#10;        val sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager&#10;        val gyroscope = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE)&#10;        sensorManager.registerListener(sensorEventListener, gyroscope, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    private fun checkPotholeFromSensors() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastDetectionTime &lt; cooldownMillis) return&#10;        if (gyroscopeValues.size &lt; WINDOW_SIZE) return&#10;        val rms = sqrt(gyroscopeValues.map { it * it }.average().toFloat())&#10;        val pothole = rms &gt; thresholdFlow.value&#10;        if (pothole) {&#10;            lastDetectionTime = now&#10;            _potholeDetected.value = true&#10;            Log.d(&quot;POTHOLE&quot;, &quot;RMS threshold exceeded. RMS=$rms, threshold=${thresholdFlow.value}&quot;)&#10;        } else {&#10;            _potholeDetected.value = false&#10;        }&#10;    }&#10;&#10;    // Game UI state&#10;    private val _uiState = MutableStateFlow(HomeUiState())&#10;    val mUiState: StateFlow&lt;HomeUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _mSensorsList = mutableStateListOf&lt;ModelHomeSensor&gt;()&#10;    val mSensorsList: SnapshotStateList&lt;ModelHomeSensor&gt; = _mSensorsList&#10;&#10;    private val _mActiveSensorListFlow = MutableStateFlow&lt;MutableList&lt;ModelHomeSensor&gt;&gt;(mutableListOf())&#10;    val mActiveSensorListFlow: StateFlow&lt;MutableList&lt;ModelHomeSensor&gt;&gt; = _mActiveSensorListFlow&#10;    private val _mActiveSensorList = mutableListOf&lt;ModelHomeSensor&gt;()&#10;&#10;    private val mIsActiveMap = mutableMapOf&lt;Int, Boolean&gt;(Pair(Sensor.TYPE_GYROSCOPE, true))&#10;    private val mChartDataManagerMap = mutableMapOf&lt;Int, MpChartDataManager&gt;()&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            SensorsProvider.getInstance().mSensorsFlow.map { value -&gt;&#10;                value.map {&#10;                    ModelHomeSensor(&#10;                        it.type,&#10;                        it.sensor,&#10;                        it.info,&#10;                        0f,&#10;                        mIsActiveMap.getOrDefault(it.type, false)&#10;                    )&#10;                }.toMutableList()&#10;            }.collectLatest {&#10;                mSensors = it&#10;                if (_mSensorsList.size == 0) {&#10;                    _mSensorsList.addAll(mSensors)&#10;                    val activeSensors = it.filter { modelHomeSensor -&gt; modelHomeSensor.isActive }&#10;                    _mActiveSensorList.addAll(activeSensors)&#10;                    _mActiveSensorListFlow.emit(_mActiveSensorList)&#10;                    getInitialChartData()&#10;                    initializeFlow()&#10;                }&#10;            }&#10;        }&#10;        SensorsProvider.getInstance().listenSensors()&#10;    }&#10;&#10;    private fun getInitialChartData() { for (sensor in _mActiveSensorList) { getChartDataManager(sensor.type) } }&#10;&#10;    // Logging to CSV (sensors)&#10;    private var csvFile: File? = null&#10;    private var writer: BufferedWriter? = null&#10;    private var isLogging = MutableStateFlow(false)&#10;    private var currentDateString: String? = null&#10;    private val tzIST: TimeZone = TimeZone.getTimeZone(&quot;Asia/Kolkata&quot;)&#10;    private val dateFormatterIST = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.US).apply { timeZone = tzIST }&#10;    private val timeFormatterIST = SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;, Locale.US).apply { timeZone = tzIST }&#10;    private var maxAxisCountCached: Int = 3&#10;&#10;    // Location tracking for CSV enrichment&#10;    private var locationManager: LocationManager? = null&#10;    private var locationListener: LocationListener? = null&#10;    @Volatile private var currentLatitude: Double? = null&#10;    @Volatile private var currentLongitude: Double? = null&#10;&#10;    fun startLocationListening(context: Context) {&#10;        try {&#10;            if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp;&#10;                ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                // No runtime permission; skip. Caller should request permission.&#10;                return&#10;            }&#10;            val lm = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager&#10;            locationManager = lm&#10;            // Initial last known&#10;            val last: Location? = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER)&#10;                ?: lm.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)&#10;            if (last != null) {&#10;                currentLatitude = last.latitude&#10;                currentLongitude = last.longitude&#10;            }&#10;            // Listener&#10;            val listener = LocationListener { loc -&gt;&#10;                currentLatitude = loc.latitude&#10;                currentLongitude = loc.longitude&#10;            }&#10;            locationListener = listener&#10;            // Request from both providers where available&#10;            try { lm.requestLocationUpdates(LocationManager.GPS_PROVIDER, 1000L, 0f, listener, Looper.getMainLooper()) } catch (_: Exception) {}&#10;            try { lm.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 2000L, 0f, listener, Looper.getMainLooper()) } catch (_: Exception) {}&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;Location&quot;, &quot;Failed to start location updates: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun stopLocationListening() {&#10;        try {&#10;            locationManager?.let { lm -&gt; locationListener?.let { ll -&gt; lm.removeUpdates(ll) } }&#10;        } catch (_: Exception) {}&#10;        locationListener = null&#10;        locationManager = null&#10;    }&#10;&#10;    private fun baseCsvDir(): File {&#10;        val docs = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS)&#10;        val folder = File(docs, &quot;SensifyCSV&quot;)&#10;        if (!folder.exists()) folder.mkdirs()&#10;        return folder&#10;    }&#10;    private fun fileForDate(dateStr: String): File = File(baseCsvDir(), &quot;sensor_data_${dateStr}.csv&quot;)&#10;&#10;    private fun openWriterForDate(dateStr: String) {&#10;        val file = fileForDate(dateStr)&#10;        val isNew = !file.exists()&#10;        writer = BufferedWriter(FileWriter(file, true))&#10;        csvFile = file&#10;        if (isNew) {&#10;            val header = StringBuilder(&quot;Time,SensorType&quot;)&#10;            var maxAxisCount = 3&#10;            for (i in 0 until SensorsConstants.MAP_TYPE_TO_AXIS_COUNT.size()) {&#10;                val axisCount = SensorsConstants.MAP_TYPE_TO_AXIS_COUNT.valueAt(i)&#10;                if (axisCount &gt; maxAxisCount) maxAxisCount = axisCount&#10;            }&#10;            maxAxisCountCached = maxAxisCount&#10;            for (i in 0 until maxAxisCount) header.append(&quot;,Value${i + 1}&quot;)&#10;            // New enrichment columns&#10;            header.append(&quot;,Latitude,Longitude,Pothole&quot;)&#10;            header.append(&quot;\n&quot;)&#10;            writer?.write(header.toString())&#10;        } else {&#10;            // Ensure cached max is computed for existing files/environment&#10;            var maxAxisCount = 3&#10;            for (i in 0 until SensorsConstants.MAP_TYPE_TO_AXIS_COUNT.size()) {&#10;                val axisCount = SensorsConstants.MAP_TYPE_TO_AXIS_COUNT.valueAt(i)&#10;                if (axisCount &gt; maxAxisCount) maxAxisCount = axisCount&#10;            }&#10;            maxAxisCountCached = maxAxisCount&#10;        }&#10;        Log.d(&quot;CSV&quot;, &quot;Logging to: ${file.absolutePath}&quot;)&#10;    }&#10;&#10;    private fun rotateIfNeeded(nowMs: Long) {&#10;        val today = dateFormatterIST.format(Date(nowMs))&#10;        if (currentDateString == null || currentDateString != today || writer == null) {&#10;            try { writer?.flush(); writer?.close() } catch (_: Exception) {}&#10;            currentDateString = today&#10;            openWriterForDate(today)&#10;        }&#10;    }&#10;&#10;    private fun startCsvLogging() { val now = System.currentTimeMillis(); rotateIfNeeded(now); isLogging.value = true }&#10;    private fun stopCsvLogging() { isLogging.value = false; try { writer?.flush(); writer?.close() } catch (_: Exception) {}; writer = null; csvFile = null; Log.d(&quot;CSV&quot;, &quot;Logging Stopped&quot;) }&#10;    fun toggleCsvLogging() { if (isLogging.value) stopCsvLogging() else startCsvLogging() }&#10;&#10;    private fun logSensorData(sensorType: Int, values: FloatArray?) {&#10;        if (isLogging.value &amp;&amp; values != null) {&#10;            val now = System.currentTimeMillis()&#10;            rotateIfNeeded(now)&#10;            val timeStr = timeFormatterIST.format(Date(now))&#10;            val sensorName = SensorsConstants.MAP_TYPE_TO_NAME[sensorType] ?: &quot;Unknown&quot;&#10;            val axisCount = SensorsConstants.MAP_TYPE_TO_AXIS_COUNT[sensorType]&#10;            val csvLine = StringBuilder()&#10;            csvLine.append(&quot;$timeStr,$sensorName&quot;)&#10;            // Write up to maxAxisCountCached columns, padding blanks as needed&#10;            for (i in 0 until maxAxisCountCached) {&#10;                val v = if (i &lt; axisCount &amp;&amp; i &lt; values.size) String.format(Locale.US, &quot;%.6f&quot;, values[i]) else &quot;&quot;&#10;                csvLine.append(&quot;,&quot;).append(v)&#10;            }&#10;            // Append location and pothole flag&#10;            val lat = currentLatitude&#10;            val lon = currentLongitude&#10;            val latStr = lat?.let { String.format(Locale.US, &quot;%.6f&quot;, it) } ?: &quot;&quot;&#10;            val lonStr = lon?.let { String.format(Locale.US, &quot;%.6f&quot;, it) } ?: &quot;&quot;&#10;            val pothole = if (potholeDetected.value) &quot;1&quot; else &quot;0&quot;&#10;            csvLine.append(&quot;,&quot;).append(latStr).append(&quot;,&quot;).append(lonStr).append(&quot;,&quot;).append(pothole)&#10;            csvLine.append(&quot;\n&quot;)&#10;            writer?.write(csvLine.toString())&#10;        }&#10;    }&#10;&#10;    private fun initializeFlow() {&#10;        val sensorPacketFlow = SensorPacketsProvider.getInstance().mSensorPacketFlow&#10;        for (sensor in _mActiveSensorList) { attachPacketListener(sensor) }&#10;        viewModelScope.launch { sensorPacketFlow.collect { logSensorData(it.type, it.values); mChartDataManagerMap[it.type]?.addEntry(it) } }&#10;        mChartDataManagerMap.forEach { (_, mpChartDataManager) -&gt; viewModelScope.launch { mpChartDataManager.runPeriodically() } }&#10;    }&#10;&#10;    private fun attachPacketListener(sensor: ModelHomeSensor) { SensorPacketsProvider.getInstance().attachSensor(SensorPacketConfig(sensor.type, SensorManager.SENSOR_DELAY_NORMAL)) }&#10;    private fun detachPacketListener(sensor: ModelHomeSensor) { SensorPacketsProvider.getInstance().detachSensor(sensor.type) }&#10;&#10;    fun onSensorChecked(type: Int, isChecked: Boolean) {&#10;        val isCheckedPrev = mIsActiveMap.getOrDefault(type, false)&#10;        if (isCheckedPrev != isChecked) mIsActiveMap[type] = isChecked&#10;        val index = mSensors.indexOfFirst { it.type == type }&#10;        if (index &gt;= 0) {&#10;            val sensor = mSensors[index]&#10;            val updatedSensor = ModelHomeSensor(sensor.type, sensor.sensor, sensor.info, sensor.valueRms, isChecked)&#10;            mSensors[index] = updatedSensor&#10;            mSensorsList[index] = updatedSensor&#10;            updateActiveSensor(updatedSensor, isChecked)&#10;        }&#10;    }&#10;&#10;    private fun updateActiveSensor(sensor: ModelHomeSensor, isChecked: Boolean = false) {&#10;        val index = _mActiveSensorList.indexOfFirst { it.type == sensor.type }&#10;        if (!isChecked &amp;&amp; index &gt;= 0) {&#10;            val manager = mChartDataManagerMap.remove(sensor.type)&#10;            manager?.destroy()&#10;            detachPacketListener(sensor)&#10;            _mActiveSensorList.removeAt(index)&#10;            viewModelScope.launch { _mActiveSensorListFlow.emit(_mActiveSensorList) }&#10;        } else if (isChecked &amp;&amp; index &lt; 0) {&#10;            _mActiveSensorList.add(sensor)&#10;            attachPacketListener(sensor)&#10;            viewModelScope.launch { _mActiveSensorListFlow.emit(_mActiveSensorList) }&#10;            getChartDataManager(type = sensor.type).runPeriodically()&#10;        }&#10;    }&#10;&#10;    fun getChartDataManager(type: Int): MpChartDataManager {&#10;        val chartDataManager = mChartDataManagerMap.getOrPut(type, defaultValue = { MpChartDataManager(type, onDestroy = { }) })&#10;        Log.d(&quot;HomeViewModel&quot;, &quot;getChartDataManager: $type&quot;)&#10;        return chartDataManager&#10;    }&#10;&#10;    fun setActivePage(page: Int?) {&#10;        viewModelScope.launch {&#10;            if (page != null &amp;&amp; _mActiveSensorList.size &gt; 0) {&#10;                if(_mActiveSensorList.size &gt; page){&#10;                    val sensor = _mActiveSensorList[page]&#10;                    _uiState.emit(_uiState.value.copy(currentSensor = sensor, activeSensorCounts = _mActiveSensorList.size))&#10;                }else{&#10;                    val sensor = _mActiveSensorList[_mActiveSensorList.size-1]&#10;                    _uiState.emit(_uiState.value.copy(currentSensor = sensor, activeSensorCounts = _mActiveSensorList.size))&#10;                }&#10;            } else {&#10;                _uiState.emit(_uiState.value.copy(currentSensor = null, activeSensorCounts = _mActiveSensorList.size))&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        // Close BLE on clear&#10;        disconnectBle()&#10;        // Stop location updates&#10;        stopLocationListening()&#10;        mChartDataManagerMap.forEach { (_, mpChartDataManager) -&gt; mpChartDataManager.destroy() }&#10;    }&#10;&#10;    // ===== BLE integration (migrated) =====&#10;    val bleConnectedDevice = MutableStateFlow&lt;BluetoothDevice?&gt;(null)&#10;    private var bleSocket: BluetoothSocket? = null&#10;    private var bleReceiverJob: Job? = null&#10;    val bleLogging = MutableStateFlow(false)&#10;&#10;    private var bleWriter: BufferedWriter? = null&#10;    private var bleCurrentDateString: String? = null&#10;    private fun bleFileForDate(dateStr: String): File = File(baseCsvDir(), &quot;bluetooth_data_${dateStr}.csv&quot;)&#10;    private fun bleOpenWriterForDate(dateStr: String) {&#10;        val file = bleFileForDate(dateStr)&#10;        val isNew = !file.exists()&#10;        bleWriter = BufferedWriter(FileWriter(file, true))&#10;        if (isNew) { bleWriter?.write(&quot;Time,Data\n&quot;) }&#10;    }&#10;    private fun bleRotateIfNeeded(nowMs: Long) {&#10;        val today = dateFormatterIST.format(Date(nowMs))&#10;        if (bleCurrentDateString == null || bleCurrentDateString != today || bleWriter == null) {&#10;            try { bleWriter?.flush(); bleWriter?.close() } catch (_: Exception) {}&#10;            bleCurrentDateString = today&#10;            bleOpenWriterForDate(today)&#10;        }&#10;    }&#10;&#10;    fun toggleBleLogging() { bleLogging.value = !bleLogging.value }&#10;&#10;    @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)&#10;    fun connectBle(device: BluetoothDevice, onError: ((Exception) -&gt; Unit)? = null) {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                // Close any previous&#10;                disconnectBle()&#10;                val socket = device.createRfcommSocketToServiceRecord(UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;))&#10;                socket.connect()&#10;                bleSocket = socket&#10;                bleConnectedDevice.emit(device)&#10;                bleReceiverJob = launch(Dispatchers.IO) { receiveBleData(socket) }&#10;            } catch (e: Exception) {&#10;                onError?.invoke(e as? Exception ?: RuntimeException(&quot;BLE error&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnectBle() {&#10;        try { bleReceiverJob?.cancel() } catch (_: Exception) {}&#10;        bleReceiverJob = null&#10;        try { bleSocket?.close() } catch (_: Exception) {}&#10;        bleSocket = null&#10;        viewModelScope.launch { bleConnectedDevice.emit(null) }&#10;        try { bleWriter?.flush(); bleWriter?.close() } catch (_: Exception) {}&#10;        bleWriter = null&#10;        bleCurrentDateString = null&#10;    }&#10;&#10;    private suspend fun receiveBleData(socket: BluetoothSocket) {&#10;        try {&#10;            val input: InputStream = socket.inputStream&#10;            val buffer = ByteArray(1024)&#10;            var carry = &quot;&quot;&#10;            while (true) {&#10;                val bytesRead = input.read(buffer)&#10;                if (bytesRead &lt;= 0) continue&#10;                val chunk = String(buffer, 0, bytesRead)&#10;                val combined = carry + chunk&#10;                val lines = combined.split('\n')&#10;                for (i in 0 until lines.size - 1) { handleBleLine(lines[i].trim()) }&#10;                carry = lines.last()&#10;            }&#10;        } catch (e: IOException) {&#10;            Log.e(&quot;BLE&quot;, &quot;receive error: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleBleLine(line: String) {&#10;        if (line.isEmpty()) return&#10;        if (bleLogging.value) {&#10;            val now = System.currentTimeMillis()&#10;            bleRotateIfNeeded(now)&#10;            val timeStr = timeFormatterIST.format(Date(now))&#10;            try { bleWriter?.write(&quot;$timeStr,$line\n&quot;) } catch (e: Exception) { Log.e(&quot;BLE&quot;, &quot;write fail: ${e.message}&quot;) }&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        // Simple factory so callers can use: viewModel(factory = HomeViewModel.Factory)&#10;        val Factory: ViewModelProvider.Factory = object : ViewModelProvider.Factory {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;                return HomeViewModel() as T&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>